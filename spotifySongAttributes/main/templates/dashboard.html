<!DOCTYPE html>
<html>
<head>
    <title>Spotify Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
    <div class="playlist-header">
        <h1>Welcome, {{ user['display_name'] }}</h1>
    </div>

    <div class="charts-container">
        <h2>Supergenre Distribution</h2>
        <div class="chart-wrapper">
            <canvas id="supergenreChart"></canvas>
        </div>

        <h4>Your top super genres:</h4>
        <ul class="genre-list" id="supergenre-list">
            {% for genre, count in user['supergenres'].items() %}
            {% if count > 0 %}
            <li class="genre-item">{{ genre }} ({{ (count | float * 100) | round(2) }}%)</li>
            {% endif %}
            {% endfor %}
        </ul>

        <h2>Subgenre Distribution</h2>
        <div class="chart-wrapper">
            <canvas id="subgenreChart"></canvas>
        </div>

        <h4>Your top subgenres:</h4>
        <ul class="genre-list" id="subgenre-list">
            {% set visible_count = 0 %}
            {% for genre, count in user['subgenres'].items() %}
            {% if count > 0 %}
            {% if visible_count < 10 %}
            <li class="genre-item">{{ genre }} ({{ (count | float * 100) | round(2) }}%)</li>
            {% set visible_count = visible_count + 1 %}
            {% else %}
            <li class="genre-item hidden extra-item">{{ genre }} ({{ (count | float * 100) | round(2) }}%)</li>
            {% endif %}
            {% endif %}
            {% endfor %}
        </ul>
        {% if visible_count >= 10 %}
        <div class="show-more-btn" id="showMoreBtn" onclick="toggleGenres()">Show More</div>
        {% endif %}
    </div>

    <!-- Comparison Section -->
    <div class="comparison-section">
        <h2>Compare with others</h2>
        <p>Enter a Spotify playlist or user URL to compare genre distributions</p>

        <div class="comparison-tabs">
            <button id="tabPlaylist" class="tab-button tab-active" onclick="switchTab('playlist')">Playlist</button>
            <button id="tabUser" class="tab-button" onclick="switchTab('user')">User</button>
        </div>

        <div id="playlistInput" class="comparison-input">
            <input type="text" id="comparePlaylistUrl" placeholder="https://open.spotify.com/playlist/..." />
            <button class="comparison-button" onclick="comparePlaylist()">Compare</button>
        </div>

        <div id="userInput" class="comparison-input" style="display: none;">
            <input type="text" id="compareUserUrl" placeholder="https://open.spotify.com/user/..." />
            <button class="comparison-button" onclick="compareUser()">Compare</button>
        </div>

        <div class="comparison-loading" id="comparisonLoading" style="display: none;">
            Loading comparison data... Please wait.
        </div>

        <div class="comparison-error" id="comparisonError"></div>

        <div class="comparison-chart-wrapper" id="comparisonChartContainer">
            <canvas id="radarComparisonChart"></canvas>
        </div>
    </div>

    <!-- Playlist Generator Section -->
    <div class="playlist-generator-section">
        <h2>Generate Playlists Based on Your Taste</h2>
        <p class="generator-description">
            This will create two playlists in your Spotify account:
            <span class="playlist-type">Similar to My Taste</span> - songs that match your current listening profile
            <span class="playlist-type">Expand My Horizons</span> - songs that might help you discover new genres
        </p>

        <div class="playlist-generator-controls">
            <div class="playlist-length-control">
                <label for="playlistLength">Number of songs in each playlist:</label>
                <input type="number" id="playlistLength" min="10" max="200" value="50">
            </div>
            <button class="generate-playlist-button" onclick="generatePlaylists()">Generate Both Playlists</button>
        </div>

        <div class="playlist-loading" id="playlistLoading" style="display: none;">
            <p>Generating your playlists... Please wait.</p>
        </div>

        <div class="playlist-result" id="playlistResultContainer" style="display: none;">
            <h3>Your Generated Playlists</h3>
        </div>

        <div class="playlist-error" id="playlistError" style="display: none;"></div>

        <div id="selectedPlaylistContainer" style="display: none;">
            <!-- Two-column layout for playlists -->
            <div class="playlists-columns">
                <div class="playlist-column">
                    <h3>Similar to My Taste</h3>
                    <div class="playlist-header-card" id="similarPlaylistHeader">
                        <div class="playlist-header-info">
                            <div class="playlist-header-text">
                                <h4>Loading playlist...</h4>
                                <p>Generating songs that match your taste</p>
                            </div>
                        </div>
                    </div>
                    <div class="playlist-tracks" id="similarPlaylistTracks">
                        <ul id="similarTracksList" class="tracks-list"></ul>
                    </div>
                </div>
                <div class="playlist-column">
                    <h3>Expand My Horizons</h3>
                    <div class="playlist-header-card" id="explorePlaylistHeader">
                        <div class="playlist-header-info">
                            <div class="playlist-header-text">
                                <h4>Loading playlist...</h4>
                                <p>Discovering new genres for you</p>
                            </div>
                        </div>
                    </div>
                    <div class="playlist-tracks" id="explorePlaylistTracks">
                        <ul id="exploreTracksList" class="tracks-list"></ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="action-buttons">
        <button class="back-button" onclick="window.location.href='/'">Back to Home</button>
    </div>

    <script>
        // Store the current user data
        let currentUserData = {
            name: "{{ user['display_name'] }}'s Listening",
            supergenres: {}
        };

        {% for genre, count in user['supergenres'].items() %}
            {% if count > 0 %}
                currentUserData.supergenres["{{ genre }}"] = {{ (count | float * 100) }};
            {% endif %}
        {% endfor %}

        function toggleGenres() {
            const items = document.querySelectorAll('#subgenre-list .extra-item');
            const button = document.getElementById('showMoreBtn');

            if (button.innerText === "Show More") {
                items.forEach(item => item.classList.remove('hidden'));
                button.innerText = "Show Less";
            } else {
                items.forEach(item => item.classList.add('hidden'));
                button.innerText = "Show More";
            }
        }

        function switchTab(tab) {
            // Update tab buttons
            document.getElementById('tabPlaylist').classList.remove('tab-active');
            document.getElementById('tabUser').classList.remove('tab-active');
            document.getElementById('tab' + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add('tab-active');

            // Update input displays
            document.getElementById('playlistInput').style.display = tab === 'playlist' ? 'flex' : 'none';
            document.getElementById('userInput').style.display = tab === 'user' ? 'flex' : 'none';

            // Reset error state
            document.getElementById('comparisonError').style.display = 'none';
            document.getElementById('comparisonError').textContent = '';
        }

        async function generatePlaylists() {
            const playlistLength = document.getElementById('playlistLength').value;

            // Validate input
            if (playlistLength < 10 || playlistLength > 100) {
                alert("Please enter a number between 10 and 100 for playlist length");
                return;
            }

            // Reset UI and show loading indicator
            document.getElementById('playlistLoading').style.display = 'block';
            document.getElementById('playlistResultContainer').style.display = 'none';
            document.getElementById('playlistError').style.display = 'none';
            document.getElementById('selectedPlaylistContainer').style.display = 'none';
            document.getElementById('similarPlaylistTracks').style.display = 'none';
            document.getElementById('explorePlaylistTracks').style.display = 'none';

            try {
                // Call the API endpoint to generate both playlists
                const response = await fetch(`/generate_similarity_playlists?length=${playlistLength}`);
                if (!response.ok) {
                    throw new Error('Failed to generate playlists');
                }

                const data = await response.json();
                console.log('Response data:', data);

                // Check if we have both playlist URLs
                if (!data.most_similar) {
                    throw new Error("Similar playlist was not generated");
                }
                if (!data.similar_clusters) {
                    throw new Error("Similar clusters playlist was not generated");
                }
                if (!data.least_similar) {
                    throw new Error("Least similar playlist was not generated");
                }

                // Extract playlist IDs from URLs
                const similarPlaylistId = extractPlaylistId(data.most_similar);
                const explorePlaylistId = extractPlaylistId(data.least_similar);

                // Store the playlist IDs and URLs for later use
                window.generatedPlaylists = {
                    similar: {
                        id: similarPlaylistId,
                        url: data.most_similar
                    },
                    explore: {
                        id: explorePlaylistId,
                        url: data.least_similar
                    }
                };

                // Fetch and display tracks for both playlists
                await fetchAndDisplayTracks(similarPlaylistId, 'similar', data);
                await fetchAndDisplayTracks(explorePlaylistId, 'explore', data);

                // Show success message
                document.getElementById('playlistResultContainer').style.display = 'block';
                document.getElementById('selectedPlaylistContainer').style.display = 'block';

            } catch (error) {
                // Show error message
                const errorElement = document.getElementById('playlistError');
                errorElement.textContent = `Error: ${error.message}`;
                errorElement.style.display = 'block';
                console.error('Error generating playlists:', error);
            } finally {
                // Hide loading indicator
                document.getElementById('playlistLoading').style.display = 'none';
            }
        }

        async function fetchAndDisplayTracks(playlistId, type) {
            try {
                // Fetch playlist tracks from our API
                const response = await fetch(`/get_playlist_tracks/${playlistId}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch playlist tracks');
                }

                const data = await response.json();
                console.log(`${type} Track data:`, data);

                // Get the tracks list element
                const tracksList = document.getElementById(`${type}TracksList`);
                tracksList.innerHTML = '';

                // Get the tracks container and header
                const tracksContainer = document.getElementById(`${type}PlaylistTracks`);
                const playlistHeader = document.getElementById(`${type}PlaylistHeader`);

                // Add tracks to the list
                if (data.tracks && data.tracks.length > 0) {
                    // Show tracks container
                    tracksContainer.style.display = 'block';

                        // Get the playlist URL to link to
                    const playlistUrl = `https://open.spotify.com/playlist/${playlistId}`;

                    // Update playlist header card with image and make it clickable
                    playlistHeader.innerHTML = `
                        <div class="playlist-header-info" onclick="window.open('${playlistUrl}', '_blank')">
                            <div class="playlist-header-text">
                                <h4>${data.playlist.name}</h4>
                                <p>${data.playlist.description || ''}</p>
                                <p>${data.playlist.tracks_count} tracks</p>
                                <span class="open-spotify-text">Open in Spotify</span>
                            </div>
                            <div class="playlist-open-icon">
                                <svg width="20" height="20" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 8.66667V12.6667C12 13.0203 11.8595 13.3594 11.6095 13.6095C11.3594 13.8595 11.0203 14 10.6667 14H3.33333C2.97971 14 2.64057 13.8595 2.39052 13.6095C2.14048 13.3594 2 13.0203 2 12.6667V5.33333C2 4.97971 2.14048 4.64057 2.39052 4.39052C2.64057 4.14048 2.97971 4 3.33333 4H7.33333" stroke="#1DB954" stroke-width="1.33" stroke-linecap="round" stroke-linejoin="round"/>
                                    <path d="M10 2H14V6" stroke="#1DB954" stroke-width="1.33" stroke-linecap="round" stroke-linejoin="round"/>
                                    <path d="M6.66675 9.33333L14.0001 2" stroke="#1DB954" stroke-width="1.33" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </div>
                        </div>
                    `;

                    // Display tracks (limited to first 20 to avoid overwhelming the UI)
                    const maxTracksToShow = Math.min(data.tracks.length, 20);
                    for (let i = 0; i < maxTracksToShow; i++) {
                        const track = data.tracks[i];
                        const trackItem = document.createElement('li');
                        trackItem.className = 'track-item';
                        trackItem.onclick = function() {
                            window.open(track.url, '_blank');
                        };

                        // Track thumbnail and info
                        trackItem.innerHTML = `
                            <div class="track-item-content">
                                ${track.image ? `<img src="${track.image}" alt="${track.name}" class="track-thumbnail">` : ''}
                                <div class="track-info">
                                    <div class="track-title">${track.name}</div>
                                    <div class="track-artist">${track.artists}</div>
                                    <div class="track-album">${track.album}</div>
                                </div>
                                <a href="${track.url}" target="_blank" class="track-link" onclick="event.stopPropagation();">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M12 8.66667V12.6667C12 13.0203 11.8595 13.3594 11.6095 13.6095C11.3594 13.8595 11.0203 14 10.6667 14H3.33333C2.97971 14 2.64057 13.8595 2.39052 13.6095C2.14048 13.3594 2 13.0203 2 12.6667V5.33333C2 4.97971 2.14048 4.64057 2.39052 4.39052C2.64057 4.14048 2.97971 4 3.33333 4H7.33333" stroke="#1DB954" stroke-width="1.33" stroke-linecap="round" stroke-linejoin="round"/>
                                        <path d="M10 2H14V6" stroke="#1DB954" stroke-width="1.33" stroke-linecap="round" stroke-linejoin="round"/>
                                        <path d="M6.66675 9.33333L14.0001 2" stroke="#1DB954" stroke-width="1.33" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                </a>
                            </div>
                        `;

                        tracksList.appendChild(trackItem);
                    }

                    // If there are more tracks, add a note
                    if (data.tracks.length > maxTracksToShow) {
                        const noteItem = document.createElement('li');
                        noteItem.className = 'track-note';
                        noteItem.textContent = `Plus ${data.tracks.length - maxTracksToShow} more tracks. Open the playlist in Spotify to see all.`;
                        tracksList.appendChild(noteItem);
                    }
                } else {
                    // No tracks found
                    tracksContainer.style.display = 'block';
                    const noTracksItem = document.createElement('li');
                    noTracksItem.textContent = 'No tracks found in this playlist.';
                    tracksList.appendChild(noTracksItem);
                }
            } catch (error) {
                console.error(`Error fetching and displaying ${type} tracks:`, error);

                // Show a fallback message
                const tracksList = document.getElementById(`${type}TracksList`);
                tracksList.innerHTML = '';

                const errorItem = document.createElement('li');
                errorItem.className = 'error-message';
                errorItem.textContent = `Couldn't load tracks: ${error.message}`;
                tracksList.appendChild(errorItem);

                document.getElementById(`${type}PlaylistTracks`).style.display = 'block';
            }
        }

        function isValidPlaylistUrl(url) {
            // Regex pattern to validate playlist URL
            const playlistPattern = /^https:\/\/open\.spotify\.com\/playlist\/[a-zA-Z0-9]+(\?.*)?$/;
            return playlistPattern.test(url);
        }

        function isValidUserUrl(url) {
            // Regex pattern to validate user URL
            const userPattern = /^https:\/\/open\.spotify\.com\/user\/[a-zA-Z0-9_-]+(\?.*)?$/;
            return userPattern.test(url);
        }

        function extractPlaylistId(url) {
            try {
                const parts = url.split('/');
                const idPart = parts[parts.length - 1].split('?')[0];
                return idPart;
            } catch (error) {
                console.error("Error extracting playlist ID:", error);
                return null;
            }
        }

        function extractUserId(url) {
            try {
                const parts = url.split('/');
                const idPart = parts[parts.length - 1].split('?')[0];
                return idPart;
            } catch (error) {
                console.error("Error extracting user ID:", error);
                return null;
            }
        }

        let radarChart = null;

        async function comparePlaylist() {
            const comparisonUrl = document.getElementById('comparePlaylistUrl').value;
            const errorElement = document.getElementById('comparisonError');
            const loadingElement = document.getElementById('comparisonLoading');
            const chartContainer = document.getElementById('comparisonChartContainer');

            // Reset state
            errorElement.style.display = 'none';
            errorElement.textContent = '';
            chartContainer.style.display = 'none';

            if (!isValidPlaylistUrl(comparisonUrl)) {
                errorElement.textContent = "Please enter a valid Spotify playlist URL.";
                errorElement.style.display = 'block';
                return;
            }

            const playlistId = extractPlaylistId(comparisonUrl);
            if (!playlistId) {
                errorElement.textContent = "Error extracting playlist ID.";
                errorElement.style.display = 'block';
                return;
            }

            // Show loading indicator
            loadingElement.style.display = 'block';

            try {
                // Fetch comparison playlist data
                const response = await fetch(`/get_playlist/${playlistId}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch playlist data');
                }

                const comparisonData = await response.json();

                // Hide loading indicator
                loadingElement.style.display = 'none';

                // Format data for radar chart
                const comparedPlaylistData = {
                    name: comparisonData.playlist_metadata.name,
                    supergenres: {}
                };

                // Convert supergenre distribution array to object
                comparisonData.supergenre_distribution.forEach(item => {
                    if (item[1] > 0) {
                        comparedPlaylistData.supergenres[item[0]] = item[1];
                    }
                });

                // Create radar chart
                createComparisonChart(currentUserData, comparedPlaylistData);

                // Show chart container
                chartContainer.style.display = 'block';

            } catch (error) {
                loadingElement.style.display = 'none';
                errorElement.textContent = "Error fetching comparison data: " + error.message;
                errorElement.style.display = 'block';
                console.error('Error:', error);
            }
        }

        async function compareUser() {
            const comparisonUrl = document.getElementById('compareUserUrl').value;
            const errorElement = document.getElementById('comparisonError');
            const loadingElement = document.getElementById('comparisonLoading');
            const chartContainer = document.getElementById('comparisonChartContainer');

            // Reset state
            errorElement.style.display = 'none';
            errorElement.textContent = '';
            chartContainer.style.display = 'none';

            if (!isValidUserUrl(comparisonUrl)) {
                errorElement.textContent = "Please enter a valid Spotify user URL.";
                errorElement.style.display = 'block';
                return;
            }

            const userId = extractUserId(comparisonUrl);
            if (!userId) {
                errorElement.textContent = "Error extracting user ID.";
                errorElement.style.display = 'block';
                return;
            }

            // Show loading indicator
            loadingElement.style.display = 'block';

            try {
                // Fetch comparison user data
                const response = await fetch(`/get_user_data/${userId}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch user data');
                }

                const userData = await response.json();

                // Hide loading indicator
                loadingElement.style.display = 'none';

                if (!userData || !userData.supergenres) {
                    throw new Error('User not found or has no listening data');
                }

                // Format data for radar chart
                const comparedUserData = {
                    name: userData.display_name || `User ${userId}`,
                    supergenres: {}
                };

                // Convert supergenre distribution to percentages if needed
                for (const [genre, value] of Object.entries(userData.supergenres)) {
                    if (value > 0) {
                        // Check if value is already a percentage or needs conversion
                        comparedUserData.supergenres[genre] = value <= 1 ? value * 100 : value;
                    }
                }

                // Create radar chart
                createComparisonChart(currentUserData, comparedUserData);

                // Show chart container
                chartContainer.style.display = 'block';

            } catch (error) {
                loadingElement.style.display = 'none';
                errorElement.textContent = "Error fetching user data: " + error.message;
                errorElement.style.display = 'block';
                console.error('Error:', error);
            }
        }

        function createComparisonChart(userData, comparisonData) {
            // Get all unique genres from both sources (excluding those with 0%)
            const allGenres = [...new Set([
                ...Object.keys(userData.supergenres),
                ...Object.keys(comparisonData.supergenres)
            ])].filter(genre =>
                (userData.supergenres[genre] || 0) > 0 ||
                (comparisonData.supergenres[genre] || 0) > 0
            );

            // Get the maximum value to determine scale
            const maxValue = Math.max(
                ...allGenres.map(genre => Math.max(
                    userData.supergenres[genre] || 0,
                    comparisonData.supergenres[genre] || 0
                ))
            );

            // Add 10% padding to the max value
            const scalePadding = 1.1;
            let suggestedMax = Math.ceil(maxValue * scalePadding);
            if (suggestedMax > 100)
                suggestedMax = 100;

            // Prepare data for radar chart
            const chartData = {
                labels: allGenres,
                datasets: [
                    {
                        label: userData.name,
                        data: allGenres.map(genre => userData.supergenres[genre] || 0),
                        backgroundColor: 'rgba(29, 185, 84, 0.2)',
                        borderColor: 'rgba(29, 185, 84, 1)',
                        pointBackgroundColor: 'rgba(29, 185, 84, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgba(29, 185, 84, 1)'
                    },
                    {
                        label: comparisonData.name,
                        data: allGenres.map(genre => comparisonData.supergenres[genre] || 0),
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        pointBackgroundColor: 'rgba(54, 162, 235, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgba(54, 162, 235, 1)'
                    }
                ]
            };

            // Create or update radar chart
            const ctx = document.getElementById('radarComparisonChart').getContext('2d');

            if (radarChart) {
                radarChart.destroy();
            }

            radarChart = new Chart(ctx, {
                type: 'radar',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            angleLines: {
                                display: true
                            },
                            suggestedMin: 0,
                            suggestedMax: suggestedMax,
                            ticks: {
                                stepSize: Math.ceil(suggestedMax / 5)
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                font: {
                                    size: 14
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: 'Taste Comparison',
                            font: {
                                size: 16
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return `${context.dataset.label}: ${context.raw.toFixed(2)}%`;
                                }
                            }
                        }
                    }
                }
            });
        }

        document.addEventListener("DOMContentLoaded", function () {
            // Extract data for subgenre chart
            const subgenreLabels = [];
            const subgenreValues = [];

            {% for genre, count in user['subgenres'].items() %}
                {% if count > 0 %}
                    subgenreLabels.push("{{ genre }}");
                    subgenreValues.push({{ count | float }});
                {% endif %}
            {% endfor %}

            // Create subgenre chart
            const subCtx = document.getElementById('subgenreChart').getContext('2d');
            new Chart(subCtx, {
                type: 'polarArea',
                data: {
                    labels: subgenreLabels,
                    datasets: [{
                        label: 'Genre Distribution',
                        data: subgenreValues,
                        backgroundColor: [
                            'rgba(255, 99, 132, 0.5)',
                            'rgba(54, 162, 235, 0.5)',
                            'rgba(255, 206, 86, 0.5)',
                            'rgba(75, 192, 192, 0.5)',
                            'rgba(153, 102, 255, 0.5)',
                            'rgba(255, 159, 64, 0.5)',
                            'rgba(199, 199, 199, 0.5)',
                            'rgba(83, 102, 255, 0.5)',
                            'rgba(255, 99, 255, 0.5)',
                            'rgba(0, 204, 102, 0.5)'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'top',
                            display: true
                        },
                        title: {
                            display: true,
                            text: 'Subgenre Distribution'
                        }
                    }
                }
            });

            // Extract data for supergenre chart
            const supergenreLabels = [];
            const supergenreValues = [];

            {% for genre, count in user['supergenres'].items() %}
                {% if count > 0 %}
                    supergenreLabels.push("{{ genre }}");
                    supergenreValues.push({{ count | float }});
                {% endif %}
            {% endfor %}

            // Create supergenre chart
            const superCtx = document.getElementById('supergenreChart').getContext('2d');
            new Chart(superCtx, {
                type: 'polarArea',
                data: {
                    labels: supergenreLabels,
                    datasets: [{
                        label: 'Genre Distribution',
                        data: supergenreValues,
                        backgroundColor: [
                            'rgba(255, 99, 132, 0.5)',
                            'rgba(54, 162, 235, 0.5)',
                            'rgba(255, 206, 86, 0.5)',
                            'rgba(75, 192, 192, 0.5)',
                            'rgba(153, 102, 255, 0.5)',
                            'rgba(255, 159, 64, 0.5)',
                            'rgba(199, 199, 199, 0.5)',
                            'rgba(83, 102, 255, 0.5)',
                            'rgba(255, 99, 255, 0.5)',
                            'rgba(0, 204, 102, 0.5)'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'top',
                            display: true
                        },
                        title: {
                            display: true,
                            text: 'Supergenre Distribution'
                        }
                    }
                }
            });
        });
    </script>
</body>
</html>